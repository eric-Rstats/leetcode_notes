[TOC]

# 动态规划

| 类型         | 标题                                                                   | 难度 | 是否解决 | 网站链接                                                                               |
| ------------ | ---------------------------------------------------------------------- | ---- | -------- | -------------------------------------------------------------------------------------- |
| 0-1背包问题  | [416.分割等和子集](../416.分割等和子集.py)                             | 中等 | ✅        | https://leetcode-cn.com/problems/partition-equal-subset-sum/                           |
| 0-1背包问题  | [1049.最后一块石头的重量II](../1049.最后一块石头的重量II.py)           | 中等 | ✅        | https://leetcode-cn.com/problems/last-stone-weight-ii/                                 |
| 0-1背包问题  | [322.零钱兑换](../322.零钱兑换.py)                                     | 中等 | ✅        | https://leetcode-cn.com/problems/coin-change/                                          |
| 0-1背包问题  | [518.零钱兑换II](../518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii.py)    | 中等 | ✅        | https://leetcode-cn.com/problems/coin-change-2/                                        |
| 0-1背包问题  | [377.组合总和Ⅳ](../377.组合总和Ⅳ.py)                                   | 中等 | ✅        | https://leetcode-cn.com/problems/combination-sum-iv/                                   |
| 0-1背包问题  | [474.一和零](../474.%E4%B8%80%E5%92%8C%E9%9B%B6.py)                    | 中等 | ✅        | https://leetcode.cn/problems/ones-and-zeroes/description/                              |
| 0-1背包问题  | [1046.最后一块石头的重量](../1046.最后一块石头的重量.py)               | 简单 |          | https://leetcode-cn.com/problems/last-stone-weight/                                    |
| 0-1背包问题  | [343.整数拆分](../343.整数拆分.py)                                     | 中等 |          | https://leetcode-cn.com/problems/integer-break/                                        |
| 0-1背包问题  | [70.爬楼梯](../70.爬楼梯.py)                                           | 简单 |          | https://leetcode-cn.com/problems/climbing-stairs/                                      |
| 完全背包问题 | [139.单词拆分](../139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.py)         | 中等 |          | https://leetcode-cn.com/problems/word-break/                                           |
| 0-1背包问题  | [279.完全平方数](../279.完全平方数.py)                                 | 中等 |          | https://leetcode-cn.com/problems/perfect-squares/                                      |
| 0-1背包问题  | [494.目标和](../494.目标和.py)                                         | 中等 |          | https://leetcode-cn.com/problems/target-sum/                                           |
| 打家劫舍问题 | [198.打家劫舍](../198.打家劫舍.py)                                     | 简单 |          | https://leetcode-cn.com/problems/house-robber/                                         |
| 打家劫舍问题 | [213.打家劫舍II](../213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-ii.py)    | 中等 |          | https://leetcode-cn.com/problems/house-robber-ii/                                      |
| 打家劫舍问题 | [337.打家劫舍III](../337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iii.py)  | 中等 |          | https://leetcode-cn.com/problems/house-robber-iii/                                     |
| 打家劫舍问题 | [2560.打家劫舍IV](../2560.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iv.py)  | 中等 |          | https://leetcode-cn.com/problems/house-robber-iv/                                      |
| 买卖股票问题 | [121.买卖股票的最佳时机](../121.买卖股票的最佳时机.py)                 | 简单 |          | https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/                      |
| 买卖股票问题 | [122.买卖股票的最佳时机II](../122.买卖股票的最佳时机II.py)             | 简单 |          | https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/                   |
| 买卖股票问题 | [123.买卖股票的最佳时机III](../123.买卖股票的最佳时机III.py)           | 困难 |          | https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/                  |
| 买卖股票问题 | [188.买卖股票的最佳时机IV](../188.买卖股票的最佳时机IV.py)             | 困难 |          | https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/                   |
| 买卖股票问题 | [309.最佳买卖股票时机含冷冻期](../309.最佳买卖股票时机含冷冻期.py)     | 中等 |          | https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/        |
| 买卖股票问题 | [714.买卖股票的最佳时机含手续费](../714.买卖股票的最佳时机含手续费.py) | 中等 |          | https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/ |
| 子序列问题   | [5.最长回文子串](../5.最长回文子串.py)                                 | 中等 |          | https://leetcode-cn.com/problems/longest-palindromic-substring/                        |
| 子序列问题   | [72.编辑距离](../72.编辑距离.py)                                       | 困难 |          | https://leetcode-cn.com/problems/edit-distance/                                        |
| 子序列问题   | [115.不同的子序列](../115.不同的子序列.py)                             | 困难 |          | https://leetcode-cn.com/problems/distinct-subsequences/                                |
| 子序列问题   | [300.最长上升子序列](../300.最长上升子序列.py)                         | 中等 |          | https://leetcode-cn.com/problems/longest-increasing-subsequence/                       |
| 子序列问题   | [392.判断子序列](../392.判断子序列.py)                                 | 简单 |          | https://leetcode-cn.com/problems/is-subsequence/                                       |
| 子序列问题   | [516.最长回文子序列](../516.最长回文子序列.py)                         | 中等 |          | https://leetcode-cn.com/problems/longest-palindromic-subsequence/                      |
| 子序列问题   | [583.两个字符串的删除操作](../583.两个字符串的删除操作.py)             | 中等 |          | https://leetcode-cn.com/problems/delete-operation-for-two-strings/                     |
| 子序列问题   | [647.回文子串](../647.回文子串.py)                                     | 中等 |          | https://leetcode-cn.com/problems/palindromic-substrings/                               |
| 子序列问题   | [674.最长连续递增序列](../674.最长连续递增序列.py)                     | 简单 |          | https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/            |
| 子序列问题   | [718.最长重复子数组](../718.最长重复子数组.py)                         | 中等 |          | https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/                  |
| 子序列问题   | [1035.不相交的线](../1035.不相交的线.py)                               | 中等 |          | https://leetcode-cn.com/problems/uncrossed-lines/                                      |
| 子序列问题   | [1143.最长公共子序列](../1143.最长公共子序列.py)                       | 中等 |          | https://leetcode-cn.com/problems/longest-common-subsequence/                           |


## 0-1背包问题


背包问题有多种背包方式，常见的有：01背包、完全背包、多重背包、分组背包和混合背包等等。


+ 一个商品如果可以重复多次放入是完全背包
+ 而只能放入一次是01背包

### 元素不可重复出现
[416.分割等和子集](../416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.py)

[1049.最后一块石头的重量ii](../1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-ii.py)

## 完全背包: 元素可以重复使用

0-1背包从大到小遍历
```
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

完全背包从小到大遍历
```
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

对于不在意顺序的,遍历先后不影响，但如果需要考虑组合，应该先遍历物品,比如
[322.零钱兑换](../322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.py)

需要考虑排列的，需要先遍历背包
[377.组合总和-ⅳ.py](../377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%B3.py)

## 打家劫舍

+ 动态规划搜寻非相邻，最多可以偷多少钱
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        # 动态规划
        n = len(nums)
        dp = [0 for _ in range(n)]
        dp[0] = nums[0]
        if n == 1:
            return dp[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, n):
            dp[i] = max(dp[i-2]+nums[i], dp[i-1])
        return dp[-1]
```

+ 如果环状，不能首尾相连，则考虑2种情况：包含首，不包含首
```python
# @lc code=start
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1: return nums[0]
        res1 = self.rob_helper(nums[1:]) # 不偷第一间
        res2 = self.rob_helper(nums[:-1]) # 不偷最后一间
        return max(res1, res2)

    def rob_helper(self, nums):
        n = len(nums)
        if n == 1:
            return nums[0]
        dp = [0 for _ in range(n)]
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, n):
            dp[i] = max(dp[i-2]+nums[i], dp[i-1])
        return dp[-1] 
```

+ 二叉树形式，迭代的时候考虑当前结点是否偷，利用后序遍历
```python
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        res = self.robTree(root)
        return max(res)
    
    def robTree(self, cur):
        # 后序遍历
        if not cur: return [0, 0]
        left_val = self.robTree(cur.left)
        right_val = self.robTree(cur.right)
        # 当前结点偷
        res1 = cur.val + left_val[0] + right_val[0]

        # 当前结点不偷
        res2 = max(left_val) + max(right_val)
        return [res2, res1]
```

+ 求最小最大值（限制条件是最多偷k家的时候，k家的最大值中，最小的): 进行二分查找，但是查找条件是是否大于k家
```python
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        n = len(nums)
        if n==1: return nums[0]

        # 检查二分的答案是否合法
        def check(x):
            dp = [0 for _ in range(n)]
            dp[0] = 1 if nums[0] <= x else 0
            dp[1] = 1 if min(nums[0], nums[1]) <= x else 0
            for i in range(2, n):
                if nums[i] <= x:
                    dp[i] = max(dp[i-1], dp[i-2]+1)
                else:
                    dp[i] = dp[i-1]
            return dp[-1]
        
        # return bisect_left(range(max(nums)), k, key=check)
            
        left, right = 0, max(nums)
        while left < right:
            mid = left + (right - left) // 2
            if check(mid) >= k:
                # 当前k过大
                right = mid
            else:
                left = mid + 1
        return left # 左边界
```

## 买卖股票

+ 交易1次, 持有和售空2个状态，有售空才有赚(或一直没操作)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 贪心
        # max_value = 0
        # min_value = inf
        # for item in prices:
        #     max_value = max(max_value, item-min_value)
        #     min_value = min(min_value, item)
        # return max_value

        # 动态规划
        hold, sell = -prices[0], 0 # 持有股票,销售股票

        for i in range(1, len(prices)):
            hold = max(hold, -prices[i])
            sell = max(sell, hold + prices[i])
        return sell
```

+ 可交易很多次,持有状态前可能有卖出
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        hold = -prices[0]
        sell = 0
        for i in range(1, n):
            hold = max(hold, sell  - prices[i]) # 当前持有(上一次卖掉,本次购入;或者上次购入,这次保持不变)
            sell = max(sell, hold + prices[i]) # 当前售出(上次售出,这次不变;或者上次购入,这次卖出)
        return sell
```

+ 可交易2次
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        sell1 = 0 #交易1次,最后无股票在手
        buy1 = -prices[0] #交易1次,最后有股票在手
        sell2 = 0 #交易2次,最后无股票在手
        buy2 = -prices[0] #交易2次,最后有股票在手
        n = len(prices)
        for p in prices:
            sell1 = max(sell1, buy1+p)
            buy1 = max(buy1, -p)
            sell2 = max(sell2, buy2+p)
            buy2 = max(buy2, sell1-p)
        return sell2
```

+ 最多可以进行k次
```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0 for _ in range(2*k+1)] for _ in range(n)]

        for i in range(1, 2*k, 2):
            dp[0][i] = -prices[0]

        # 单数表示此时买入, 双数表示此时售空
        for i in range(1, n):
            for j in range(0, 2*k-1, 2):
                # 单数
                dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j]-prices[i])
                # 双数
                dp[i][j+2] = max(dp[i-1][j+2], dp[i-1][j+1]+prices[i])
        return dp[-1][2*k]
```

+ 买卖包含冷冻期
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 状态1：持有股票
        # 状态2：保持无股票在手
        # 状态3: 今天卖出股票
        # 状态4: 冷冻期,则一定前一天卖出了股票
        # n = len(prices)
        # dp = [[0 for _ in range(4)] for _ in range(n)]
        # dp[0][0] = -prices[0]
        # for i in range(1, n):
        #     dp[i][0] = max(dp[i-1][0], max(dp[i-1][1]-prices[i], dp[i-1][3]-prices[i]))
        #     dp[i][1] = max(dp[i-1][1], dp[i-1][3])
        #     dp[i][2] = dp[i-1][0] + prices[i]
        #     dp[i][3] = dp[i-1][2]
        # return max(dp[-1])

        n = len(prices)
        if n < 2:
            return 0
        sell = [0] * n
        buy = [0] * n
        buy[0] = -prices[0]
        buy[1] = max(buy[0], -prices[1])
        sell[1] = max(sell[0], buy[0]+prices[1])
        for i in range(2, n):
            buy[i] = max(buy[i-1], sell[i-2]-prices[i]) 
            sell[i] = max(sell[i-1], buy[i-1]+prices[i])
        return max(sell[-1], sell[-2])
```

+ 买卖包含手续费
```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        # n = len(prices)
        # dp = [[0,0] for _ in range(n)]
        # dp[0][0] = -prices[0]
        # for i in range(1, n):
        #     # 持有状态
        #     dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i])
        #     # 售空状态
        #     dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]-fee)
        # return max(dp[-1])

        n = len(prices)
        hold, sell = -prices[0], 0
        for i in range(1, n):
            hold = max(hold, sell-prices[i])
            sell = max(sell, hold+prices[i]-fee)
        return max(sell, hold)
```

## 最长子序列/子数组

+ 最长递增子序列

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        if n <= 1:
            return n
        dp = [1 for _ in range(n)]
        for i in range(n):
            for j in range(0, i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j]+1)
        return max(dp)
```

+ 最长连续递增序列
```python
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        n = len(nums)
        if not nums or n < 0:
            return 0
        dp = [1] * n

        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                dp[i] = dp[i - 1] + 1

        return max(dp)
```

+ 最大子序列和：连续累加/或者从头开始
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:

        # 版本1: 贪心
        # res = -float('inf')
        # total = 0
        # for item in nums:
        #     total += item
        #     if total > res:
        #         res = total
        #     if total < 0:
        #         total = 0
        # return res

        dp = [0 for _ in range(len(nums))]
        dp[0] = nums[0]
        res = dp[0]
        for i in range(1, len(nums)):
            # 到i的最长数组,要么是连续，要么是从头开始累积
            dp[i] = max(dp[i-1]+nums[i], nums[i])
            if dp[i] > res:
                res = dp[i]

        return res
```


+ 2个数组, 最长重复子数组的长度.定义dp[i][j]为两个数组，分别以i和
j结尾时，可构成的最长重复数据的长度

```python
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        m, n = len(nums1), len(nums2)
        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
        res = 0
        for i in range(1, m+1):
            for j in range(1, n+1):
                if nums2[j-1] == nums1[i-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                res = max(res, dp[i][j])
        return res
```


+ 最长公共子序列: 非连续的，2个数组的公共部分
```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
        for i in range(1, m+1):
            for j in range(1, n+1):
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        return dp[-1][-1]
```

+ 判断子序列: 与【最长公共子序列】的区别在于，用于匹配的子数组，不能剔除元素，一定得保证每个元素都使用。

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:

        m, n = len(s), len(t)
        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
        for i in range(1, m+1):
            for j in range(1, n+1):
                if s[i-1] == t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = dp[i][j-1]
        return dp[-1][-1] == m
```

+ 不同的子序列:子序列匹配到的次数，匹配到的时候,可能之前已经有匹配到的，因此可以选择不用这个元素来匹配
```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]

        # 初始化细节
        for i in range(m):
            dp[i][0] = 1 # 可以首元素不取，也能认为匹配到
        for i in range(1, n):
            dp[0][i] = 0 

        for i in range(1, m+1):
            for j in range(1, n+1):
                if s[i-1] == t[j-1]:
                    # 也可以不用这个元素来匹配,需要累积可能性
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[-1][-1]
```

+ 两个字符串中的删除操作
```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:

        m, n = len(word1), len(word2)
        dp = [[0 for _ in range(n+1)] for j in range(m+1)]

        for i in range(m+1):
            dp[i][0] = i
        for j in range(n+1):
            dp[0][j] = j
        

        for i in range(1, m+1):
            for j in range(1, n+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1
        return dp[-1][-1]
```


+ 编辑距离：和上一题类似,只是多了一种替换操作
```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m, n = len(word1), len(word2)
        dp = [[0 for _ in range(n+1)] for j in range(m+1)]

        for i in range(m+1):
            dp[i][0] = i
        for j in range(n+1):
            dp[0][j] = j
        

        for i in range(1, m+1):
            for j in range(1, n+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
        return dp[-1][-1]
```

+ 回文子串
```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        dp = [[False for _ in range(n)] for _ in range(n)]
        res = 0
        for i in range(n-1, -1, -1):
            for j in range(i, n):
                if s[i] == s[j]:
                    if j - i <= 1:
                        res += 1
                        dp[i][j] =True
                    elif dp[i+1][j-1]:
                        res += 1
                        dp[i][j] =True
        return res
```

+ 最长回文子序列
```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)
        if n <= 1:
            return n

        dp = [[0] * n for _ in range(n)]
        for i in range(n):
            dp[i][i] = 1

        # 反向遍历
        for i in range(n - 2, -1, -1):
            for j in range(i+1, n, 1):
                if s[i] == s[j]:
                    dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                    dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])

        return dp[0][-1]
```