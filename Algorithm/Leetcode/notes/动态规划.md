[TOC]

# 动态规划

| 类型         | 标题                                                                   | 难度 | 是否解决 | 网站链接                                                                               |
| ------------ | ---------------------------------------------------------------------- | ---- | -------- | -------------------------------------------------------------------------------------- |
| 0-1背包问题  | [416.分割等和子集](../416.分割等和子集.py)                             | 中等 | ✅        | https://leetcode-cn.com/problems/partition-equal-subset-sum/                           |
| 0-1背包问题  | [1049.最后一块石头的重量II](../1049.最后一块石头的重量II.py)           | 中等 | ✅        | https://leetcode-cn.com/problems/last-stone-weight-ii/                                 |
| 0-1背包问题  | [322.零钱兑换](../322.零钱兑换.py)                                     | 中等 | ✅        | https://leetcode-cn.com/problems/coin-change/                                          |
| 0-1背包问题  | [518.零钱兑换II](../518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii.py)    | 中等 | ✅        | https://leetcode-cn.com/problems/coin-change-2/                                        |
| 0-1背包问题  | [377.组合总和Ⅳ](../377.组合总和Ⅳ.py)                                   | 中等 | ✅        | https://leetcode-cn.com/problems/combination-sum-iv/                                   |
| 0-1背包问题  | [474.一和零](../474.%E4%B8%80%E5%92%8C%E9%9B%B6.py)                    | 中等 | ✅        | https://leetcode.cn/problems/ones-and-zeroes/description/                              |
| 0-1背包问题  | [1046.最后一块石头的重量](../1046.最后一块石头的重量.py)               | 简单 |          | https://leetcode-cn.com/problems/last-stone-weight/                                    |
| 0-1背包问题  | [343.整数拆分](../343.整数拆分.py)                                     | 中等 |          | https://leetcode-cn.com/problems/integer-break/                                        |
| 0-1背包问题  | [70.爬楼梯](../70.爬楼梯.py)                                           | 简单 |          | https://leetcode-cn.com/problems/climbing-stairs/                                      |
| 完全背包问题 | [139.单词拆分](../139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.py)         | 中等 |          | https://leetcode-cn.com/problems/word-break/                                           |
| 0-1背包问题  | [279.完全平方数](../279.完全平方数.py)                                 | 中等 |          | https://leetcode-cn.com/problems/perfect-squares/                                      |
| 0-1背包问题  | [494.目标和](../494.目标和.py)                                         | 中等 |          | https://leetcode-cn.com/problems/target-sum/                                           |
| 打家劫舍问题 | [198.打家劫舍](../198.打家劫舍.py)                                     | 简单 |          | https://leetcode-cn.com/problems/house-robber/                                         |
| 打家劫舍问题 | [213.打家劫舍II](../213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-ii.py)    | 中等 |          | https://leetcode-cn.com/problems/house-robber-ii/                                      |
| 打家劫舍问题 | [337.打家劫舍III](../337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iii.py)  | 中等 |          | https://leetcode-cn.com/problems/house-robber-iii/                                     |
| 打家劫舍问题 | [2560.打家劫舍IV](../2560.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iv.py)  | 中等 |          | https://leetcode-cn.com/problems/house-robber-iv/                                      |
| 买卖股票问题 | [121.买卖股票的最佳时机](../121.买卖股票的最佳时机.py)                 | 简单 |          | https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/                      |
| 买卖股票问题 | [122.买卖股票的最佳时机II](../122.买卖股票的最佳时机II.py)             | 简单 |          | https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/                   |
| 买卖股票问题 | [123.买卖股票的最佳时机III](../123.买卖股票的最佳时机III.py)           | 困难 |          | https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/                  |
| 买卖股票问题 | [188.买卖股票的最佳时机IV](../188.买卖股票的最佳时机IV.py)             | 困难 |          | https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/                   |
| 买卖股票问题 | [309.最佳买卖股票时机含冷冻期](../309.最佳买卖股票时机含冷冻期.py)     | 中等 |          | https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/        |
| 买卖股票问题 | [714.买卖股票的最佳时机含手续费](../714.买卖股票的最佳时机含手续费.py) | 中等 |          | https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/ |


## 0-1背包问题


背包问题有多种背包方式，常见的有：01背包、完全背包、多重背包、分组背包和混合背包等等。


+ 一个商品如果可以重复多次放入是完全背包
+ 而只能放入一次是01背包

### 元素不可重复出现
[416.分割等和子集](../416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.py)

[1049.最后一块石头的重量ii](../1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-ii.py)

## 完全背包: 元素可以重复使用

0-1背包从大到小遍历
```
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

完全背包从小到大遍历
```
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

对于不在意顺序的,遍历先后不影响，但如果需要考虑组合，应该先遍历物品,比如
[322.零钱兑换](../322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.py)

需要考虑排列的，需要先遍历背包
[377.组合总和-ⅳ.py](../377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%B3.py)

## 打家劫舍

+ 动态规划搜寻非相邻，最多可以偷多少钱
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        # 动态规划
        n = len(nums)
        dp = [0 for _ in range(n)]
        dp[0] = nums[0]
        if n == 1:
            return dp[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, n):
            dp[i] = max(dp[i-2]+nums[i], dp[i-1])
        return dp[-1]
```

+ 如果环状，不能首尾相连，则考虑2种情况：包含首，不包含首
```python
# @lc code=start
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1: return nums[0]
        res1 = self.rob_helper(nums[1:]) # 不偷第一间
        res2 = self.rob_helper(nums[:-1]) # 不偷最后一间
        return max(res1, res2)

    def rob_helper(self, nums):
        n = len(nums)
        if n == 1:
            return nums[0]
        dp = [0 for _ in range(n)]
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, n):
            dp[i] = max(dp[i-2]+nums[i], dp[i-1])
        return dp[-1] 
```

+ 二叉树形式，迭代的时候考虑当前结点是否偷，利用后序遍历
```python
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        res = self.robTree(root)
        return max(res)
    
    def robTree(self, cur):
        # 后序遍历
        if not cur: return [0, 0]
        left_val = self.robTree(cur.left)
        right_val = self.robTree(cur.right)
        # 当前结点偷
        res1 = cur.val + left_val[0] + right_val[0]

        # 当前结点不偷
        res2 = max(left_val) + max(right_val)
        return [res2, res1]
```

+ 求最小最大值（限制条件是最多偷k家的时候，k家的最大值中，最小的): 进行二分查找，但是查找条件是是否大于k家
```python
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        n = len(nums)
        if n==1: return nums[0]

        # 检查二分的答案是否合法
        def check(x):
            dp = [0 for _ in range(n)]
            dp[0] = 1 if nums[0] <= x else 0
            dp[1] = 1 if min(nums[0], nums[1]) <= x else 0
            for i in range(2, n):
                if nums[i] <= x:
                    dp[i] = max(dp[i-1], dp[i-2]+1)
                else:
                    dp[i] = dp[i-1]
            return dp[-1]
        
        # return bisect_left(range(max(nums)), k, key=check)
            
        left, right = 0, max(nums)
        while left < right:
            mid = left + (right - left) // 2
            if check(mid) >= k:
                # 当前k过大
                right = mid
            else:
                left = mid + 1
        return left # 左边界
```

## 买卖股票

+ 交易1次, 持有和售空2个状态，有售空才有赚(或一直没操作)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 贪心
        # max_value = 0
        # min_value = inf
        # for item in prices:
        #     max_value = max(max_value, item-min_value)
        #     min_value = min(min_value, item)
        # return max_value

        # 动态规划
        hold, sell = -prices[0], 0 # 持有股票,销售股票

        for i in range(1, len(prices)):
            hold = max(hold, -prices[i])
            sell = max(sell, hold + prices[i])
        return sell
```

+ 可交易很多次,持有状态前可能有卖出
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        hold = -prices[0]
        sell = 0
        for i in range(1, n):
            hold = max(hold, sell  - prices[i]) # 当前持有(上一次卖掉,本次购入;或者上次购入,这次保持不变)
            sell = max(sell, hold + prices[i]) # 当前售出(上次售出,这次不变;或者上次购入,这次卖出)
        return sell
```

+ 可交易2次
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        sell1 = 0 #交易1次,最后无股票在手
        buy1 = -prices[0] #交易1次,最后有股票在手
        sell2 = 0 #交易2次,最后无股票在手
        buy2 = -prices[0] #交易2次,最后有股票在手
        n = len(prices)
        for p in prices:
            sell1 = max(sell1, buy1+p)
            buy1 = max(buy1, -p)
            sell2 = max(sell2, buy2+p)
            buy2 = max(buy2, sell1-p)
        return sell2
```

+ 最多可以进行k次
```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0 for _ in range(2*k+1)] for _ in range(n)]

        for i in range(1, 2*k, 2):
            dp[0][i] = -prices[0]

        # 单数表示此时买入, 双数表示此时售空
        for i in range(1, n):
            for j in range(0, 2*k-1, 2):
                # 单数
                dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j]-prices[i])
                # 双数
                dp[i][j+2] = max(dp[i-1][j+2], dp[i-1][j+1]+prices[i])
        return dp[-1][2*k]
```

+ 买卖包含冷冻期
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 状态1：持有股票
        # 状态2：保持无股票在手
        # 状态3: 今天卖出股票
        # 状态4: 冷冻期,则一定前一天卖出了股票
        # n = len(prices)
        # dp = [[0 for _ in range(4)] for _ in range(n)]
        # dp[0][0] = -prices[0]
        # for i in range(1, n):
        #     dp[i][0] = max(dp[i-1][0], max(dp[i-1][1]-prices[i], dp[i-1][3]-prices[i]))
        #     dp[i][1] = max(dp[i-1][1], dp[i-1][3])
        #     dp[i][2] = dp[i-1][0] + prices[i]
        #     dp[i][3] = dp[i-1][2]
        # return max(dp[-1])

        n = len(prices)
        if n < 2:
            return 0
        sell = [0] * n
        buy = [0] * n
        buy[0] = -prices[0]
        buy[1] = max(buy[0], -prices[1])
        sell[1] = max(sell[0], buy[0]+prices[1])
        for i in range(2, n):
            buy[i] = max(buy[i-1], sell[i-2]-prices[i]) 
            sell[i] = max(sell[i-1], buy[i-1]+prices[i])
        return max(sell[-1], sell[-2])
```

+ 买卖包含手续费
```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        # n = len(prices)
        # dp = [[0,0] for _ in range(n)]
        # dp[0][0] = -prices[0]
        # for i in range(1, n):
        #     # 持有状态
        #     dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i])
        #     # 售空状态
        #     dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]-fee)
        # return max(dp[-1])

        n = len(prices)
        hold, sell = -prices[0], 0
        for i in range(1, n):
            hold = max(hold, sell-prices[i])
            sell = max(sell, hold+prices[i]-fee)
        return max(sell, hold)
```
